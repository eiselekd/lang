: # -*-Mode: perl;-*- use perl, wherever it is
eval 'exec perl -wS $0 ${1+"$@"}'
  if 0;
# $Id$
######################################################################
#
# Copyright 2003-2006 by Wilson Snyder. This program is free software; you can
# redistribute it and/or modify it under the terms of either the GNU
# General Public License or the Perl Artistic License.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
######################################################################

require 5.006_001;
use warnings;
BEGIN {
    if (my $Project=($ENV{DIRPROJECT}||$ENV{PROJECT})) {
	# Magic to allow author testing of perl packages in local directory
	require "$Project/hw/utils/perltools/boot.pl";
    }
}

use File::Path;
use File::Basename;
use Getopt::Long;
use FindBin qw($RealBin $RealScript);
use IO::File;
use Pod::Usage;
use Config;
use Cwd qw(abs_path getcwd);

use strict;
use vars qw ($Debug %Vars $Opt $Opt_Make_Dir $Opt_Sp @Opt_Verilator_Sw
	     $Opt_Trace
	     %Modules
	     );

#######################################################################
# Global constants -- Configuration info

# Where to find real executables
# We could find it by using $RealBin, but we require this path
# so that when the user runs make, they will have it and not get strange error.
$ENV{VERILATOR_ROOT} or die "%Error: verilator: VERILATOR_ROOT needs to be in environment\n";
print "export VERILATOR_ROOT=$ENV{VERILATOR_ROOT}\n" if $Debug;

# Read by verilator for populating makefile
if (!defined $ENV{SYSTEMC_ARCH}) {
    $ENV{SYSTEMC_ARCH} ||= (($Config{osname} =~ /solaris/i && "gccsparcOS5")
			    || ($Config{osname} =~ /cygwin/i && "cygwin")
			    || "linux");
    print "export SYSTEMC_ARCH=$ENV{SYSTEMC_ARCH}\n" if $Debug;
}

#######################################################################
#######################################################################
# main

autoflush STDOUT 1;
autoflush STDERR 1;

$Debug = 0;
my $opt_gdb;
$Opt_Sp = undef;

# No arguments can't do anything useful.  Give help
if ($#ARGV < 0) {
    pod2usage(-exitstatus=>2, -verbose=>0);
}

# Insert debugging options up front
push @ARGV, (split ' ',$ENV{VERILATOR_TEST_FLAGS}||"");

# We sneak a look at the flags so we can do some pre-environment checks
# All flags will hit verilator...
@Opt_Verilator_Sw = @ARGV;

Getopt::Long::config ("no_auto_abbrev","pass_through");
if (! GetOptions (
		  # Major operating modes
		  "help"	=> \&usage,
		  "debug:s"	=> \&debug,
		  "version!"	=> \&version,
		  # Switches
		  "gdb=s"	=> \$opt_gdb,	# Undocumented debugging
		  "trace!"	=> \$Opt_Trace,
		  "sp!"		=> sub {$Opt_Sp = 'sp';},
		  "sc!"		=> sub {$Opt_Sp = 'sc';},
		  "cc!"		=> sub {$Opt_Sp = 0;},
		  #"ignc!"	=> ...,		# Undocumented debugging, disable $c but don't complain
		  # Additional parameters
		  "<>"		=> sub {},	# Ignored
		  )) {
    pod2usage(-exitstatus=>2, -verbose=>0);
}

# Check configuration
if ($Opt_Sp) {
    (defined $ENV{SYSTEMC}) or die "%Error: verilator: Need \$SYSTEMC in environment\nProbably System-C isn't installed, see http://www.systemc.org\n";
}
if ($Opt_Sp eq 'sp' || $Opt_Trace) {
    if (!defined $ENV{SYSTEMPERL}) {
	my $try = "$ENV{W}/hw/utils/perltools/SystemC/src";
	$ENV{SYSTEMPERL} = $try if -d $try;
    }
    (defined $ENV{SYSTEMPERL}) or die "%Error: verilator: Need \$SYSTEMPERL in environment for --sp or --trace\nProbably System-Perl isn't installed, see http://www.veripool.com/systemperl.html\n";
}

# Determine runtime flags
my $vcmd =(($opt_gdb?"$opt_gdb ":"")
	   .verilator_bin()
	   ." --bin ".verilator_bin()	# So we get binary name into .d file
	   ." ".join(' ',@Opt_Verilator_Sw)
	   );

# Run verilator
run ($vcmd);

#----------------------------------------------------------------------

sub usage {
    bin_version();
    print '$Revision$$Date$ ', "\n";
    pod2usage(-exitstatus=>2, -verbose=>2);
}

sub debug {
    shift;
    my $level = shift;
    $Debug = $level||3;
}

sub version {
    bin_version();
    exit (0);
}

sub bin_version {
    ($ENV{VERILATOR_ROOT}) or print "%Warning: Unknown rev: VERILATOR_ROOT undefined\n";
    run (verilator_bin()." --version");
}

#######################################################################
#######################################################################
# Builds

sub verilator_bin {
    my $bin = "$ENV{VERILATOR_ROOT}/".($ENV{VERILATOR_BIN}||"verilator_bin");
    if ($Debug && -x "${bin}_dbg") { $bin = "${bin}_dbg"; }
    return $bin;
}

#######################################################################
#######################################################################
# Utilities

sub run {
    # Run command, check errors
    my $command = shift;
    print "\t$command\n" if $Debug>=3;
    system($command);
    my $status = $?;
    if ($status) {
	if ($Debug) {  # For easy rerunning
	    warn "%Error: export VERILATOR_ROOT=$ENV{VERILATOR_ROOT}\n";
	    warn "%Error: $command\n";
	}
	die "%Error: Command Failed $command, $status, stopped";
    }
}

#######################################################################
#######################################################################
package main;
__END__

=pod

=head1 NAME

Verilator - Convert Verilog code to C++/SystemC

=head1 SYNOPSIS

    verilator --help
    verilator --version
    verilator --cc [options] [top_level.v] [opt_c_files.cpp/c/cc]
    verilator --sc [options] [top_level.v] [opt_c_files.cpp/c/cc]
    verilator --sp [options] [top_level.v] [opt_c_files.cpp/c/cc]

=head1 DESCRIPTION

Verilator converts synthesizable (not behavioral) Verilog code, plus some
Synthesis, SystemVerilog and Sugar/PSL assertions, into C++, SystemC or
SystemPerl code.  It is not a complete simulator, just a compiler.

Verilator is invoked with parameters similar to GCC, Cadence
Verilog-XL/NC-Verilog, or Synopsys's VCS.  It reads the specified Verilog
code, lints it, and optionally adds coverage and waveform tracing code.
For C++ and SystemC formats, it outputs .cpp and .h files.  For SystemPerl
format, it outputs .sp files for the SystemPerl preprocessor, which greatly
simplifies writing SystemC code and is available at
L<http://www.veripool.com>.

The files created by Verilator are then compiled with C++.  The user writes
a little C++ wrapper file, which instantiates the top level module, and
passes this filename on the command line.  These C files are compiled in
C++, and linked with the Verilated files.

The resulting executable will perform the actual simulation.

=head1 ARGUMENTS

=over 4

=item {file.v}

Specifies the Verilog file containing the top module to be Verilated.

=item {file.c/cc/cpp}

Specifies optional C++ files to be linked in with the Verilog code.  If any
C++ files are specified in this way, Verilator will include a make rule
that generates a I<module> executable.  Without any C++ files, Verilator
will stop at the I<module>__ALL.a library, and presume you'll continue
linking with make rules you write yourself.

=item --assert

Enable all assertions, includes enabling the --psl flag.  (If psl is not
desired, but other assertions are, use --assert --nopsl.)

=item --cc

Specifies C++ without SystemC output mode; see also --sc and --sp.

=item --coverage

Enables all forms of coverage, alias for --coverage-line, --coverage-user

=item --coverage-line

Specifies basic block line coverage analysis code should be inserted.

Coverage analysis adds statements at each code flow change point, which are
the branches of IF and CASE statements, a superset of normal Verilog Line
Coverage.  At each such branch a C++ macro is called, which SystemPerl uses
to increment an array.  At the end of a test, logs/coverage.pl is written
with the data from the array.

After running multiple tests, the vcoverage utility (from the SystemPerl
package) is executed.  Vcoverage reads the logs/coverage.pl file(s), and
creates an annotated source code listing showing code coverage details.

Verilator automatically disables coverage of branches that have a $stop in
them, as it is assumed $stop branches contain an error check that should
not occur.  A /*verilator coverage_block_off*/ comment will perform a
similar function on any code in that block or below.

For an example, after running 'make test' in the Verilator distribution,
see the test_sp/logs/coverage_source directory.  Grep for lines starting
with '%' to see what lines Verilator believes need more coverage.

=item --coverage-user

Enables user inserted functional coverage.  Currently, all functional
coverage points are specified using PSL which must be separately enabled
with --psl.

For example, the following PSL statement will add a coverage point, with
the comment "DefaultClock":

   // psl default clock = posedge clk;
   // psl cover {cyc==9} report "DefaultClock,expect=1";

=item --debug

Select the debug built image of Verilator (if available), and enable
debugging messages and intermediate form dump files.

=item -E

Preprocess the source code, but do not compile, as with 'gcc -E'.  Output
is written to standard out.  Beware of enabling debugging messages, as they
will also go to standard out.

=item --exe

Generate a executable.  You will also need to pass additional .cpp files on
the command line that implement the main loop for your simulation.

=item --help

Displays this message and program version and exits.

=item --inhibit-sim

Create a "inhibitSim(bool)" function to enable and disable evaluation.
This allows a upper level testbench to disable modules that are not
important in a given simulation, without needing to recompile or change the
SystemC modules instantiated.

=item --inline-mult I<value>

Tune the inlining of modules.  The default value of 2000 specifies that up
to 2000 new operations may be added to the model by inlining, if more then
this number of operations would result, the module is not inlined.  Larger
values, or -1 to inline everything, will lead to longer compile times, but
potentially faster runtimes.  This setting is ignored for very small
modules; they will always be inlined, if allowed.

=item --MMD

Enable creation of .d dependency files, used for make dependency detection,
similar to gcc -MMD option.  On by default, use --no-MMD to disable.

=item --MP

When creating .d dependency files with --MMD, make phony targets.  Similar
to gcc -MP option.

=item --Mdir I<directory>

Specifies the name of the Make object directory.  All generated files will
be placed in this directory.

=item --mod-prefix I<topname>

Specifies the name to prepend to all lower level classes.  Defaults to
the same as --prefix.

=item --no-skip-identical

Disables skipping execution of Verilator if all source files are identical,
and all output files exist with newer dates.

=item -O0

Disables optimization of the model.

=item -O3

Enables slow optimizations.  This may reduce simulation runtimes at the
cost of compile time.  This currently sets --inline-mult -1.

=item -OI<optimization-letter>

Enables or disables a specific optimizations, with the optimization
selected based on the letter passed.  A lowercase letter disables an
optimization, an upper case letter enables it.  This is intended for
debugging use only; see the source code for version-dependent mappings of
optimizations to -O letters.

=item --output-split I<bytes>

Enables splitting the output .cpp/.sp files into multiple outputs.  When a
C++ file exceeds the specified number of operations, a new file will be
created.  In addition, any slow routines will be placed into __Slow files.
This accelerates compilation by as optimization can be disabled on the slow
routines, and the remaining files can be compiled on parallel machines.
With GCC 3.3 on a 2GHz Opteron, --output-split 20000 will result in
splitting into approximately one-minute-compile chunks.

=item --pins64

Specifies SystemC outputs of 33-64 bits wide should use uint64_t instead of
the backward-compatible default of sc_bv's.

=item --prefix I<topname>

Specifies the name of the top level class.  Defaults to the name of the top
level Verilog module.

=item --profile-cfuncs

Modify the created C++ functions to support profiling.  The functions will
be minimized to contain one "basic" statement, generally a single always
block or wire statement.  (Note this will slow down the executable by ~5%.)
Furthermore, the function name will be suffixed with the basename of the
Verilog module and line number the statement came from.  This allows gprof
or oprofile reports to be correlated with the original Verilog source
statements.

=item --private

Opposite of --public.  Is the default; this option exists for backwards
compatibility.

=item --psl

Enable PSL parsing.  Without this switch, psl meta-comments are ignored.
See the --assert flag to enable all assertions, and --coverage-user to
enable functional coverage.

=item --public

Declares all signals and modules public.  This will turn off signal
optimizations as if all signals had a /*verilator public*/ comments.  This
will also turn off inlining as if all modules had a /*verilator
public_module*/, unless the module specifically enabled it with /*verilator
inline_module*/.

=item --sc

Specifies SystemC output mode; see also --cc and -sp.

=item --sp

Specifies SystemPerl output mode; see also --cc and -sc.

=item --stats

Creates a dump file with statistics on the design in {prefix}__stats.txt.

=item --trace

Adds waveform tracing code to the model.  Having tracing compiled in may
result in some small performance losses, even when waveforms are not turned
on during model execution.

=item --underline-zero

Signals starting with a underline should be initialized to zero, as was
done in Verilator 2.  Default is for all signals including those with
underlines being randomized.  This option may be depreciated in future
versions.

=item -Werror-I<message>

Convert the specified warning message into a error message.  This is
generally to discourage users from violating important site-wide rules, for
example C<-Werror-NOUNOPTFLAT>.

=item -Wno-I<message>

Disable the specified warning message.

=item -x-assign 0

=item -x-assign 1

=item -x-assign unique  (default)

Controls the two-state value that is replaced when an assignment to X is
encountered.  -x-assign=0 converts all Xs to 0s, this is the fastest.
-x-assign=1 converts all Xs to 1s, this is nearly as fast, but more likely
to find reset bugs as active high logic will fire.  The default,
-x-assign=func will call a function to determine the value, this allows
randomization of all Xs and is the slowest, but safest.

=back

=head1 VERILOG ARGUMENTS

The following arguments are compatible with GCC, VCS and most Verilog
programs.

=over 4

=item +define+I<var>+I<value>

=item -DI<var>=I<value>

Defines the given preprocessor symbol.

=item -f I<file>

Read the specified file, and act as if all text inside it was
specified as command line parameters.

=item +incdir+I<dir>

=item -II<dir>

=item -y I<dir>

Add the directory to the list of directories that should be searched
for include directories or libraries.

=item +libext+I<ext>+I<ext>...

Specify the extensions that should be used for finding modules.  If for
example module I<x> is referenced, look in I<x>.I<ext>.

=item -UI<var>

Undefines the given preprocessor symbol.

=item -v I<filename>

Read the filename as a Verilog library.  Any modules in the file may be
used to resolve cell instantiations in the top level module, else ignored.

=back

=head1 EXAMPLE C++ EXECUTION

We'll compile this example into C++.

    mkdir test_our
    cd test_our

    cat <<EOF >our.v
      module our;
         initial begin \$display("Hello World"); \$finish; end
      endmodule
    EOF

    cat <<EOF >sim_main.cpp
      #include "Vour.h"
      #include "verilated.h"
      int main(int argc, char **argv, char **env) {
          Vour* top = new Vour;
          while (!Verilated::gotFinish()) { top->eval(); }
      }
    EOF

Now we run Verilator on our little example.

    export VERILATOR_ROOT=/path/to/where/verilator/was/installed
    $VERILATOR_ROOT/bin/verilator --cc our.v --exe sim_main.cpp

We can see the source code under the "obj_dir" directory.  See the FILES
section below for descriptions of some of the files that were created.

    ls -l obj_dir

We then can compile it

    cd obj_dir
    make -f Vour.mk Vour

(Verilator included a default compile rule and link rule, since we used
--exe and passed a .cpp file on the Verilator command line.  You can also
write your own compile rules, as we'll show in the SYSTEMC section.)

And now we run it

    cd ..
    obj_dir/Vour

And we get as output

    Hello World
    - our.v:2: Verilog $finish

Really, you're better off using a Makefile to do all this for you.  Then,
when your source changes it will automatically run all of these steps.  See
the test_c directory in the distribution for an example.

=head1 EXAMPLE SYSTEMC EXECUTION

This is an example similar to the above, but using SystemPerl.

    mkdir test_our_sc
    cd test_our_sc

    cat <<EOF >our.v
      module our (clk);
         input clk;  // Clock is required to get initial activation
         always @ (posedge clk)
            begin \$display("Hello World"); \$finish; end
      endmodule
    EOF

    cat <<EOF >sc_main.cpp
      #include "Vour.h"
      #include "systemperl.h"
      int sc_main(int argc, char **argv) {
          sc_clock clk ("clk",10, 0.5, 3, true);
          Vour* top;
          SP_CELL (top, Vour);
          SP_PIN  (top, clk, clk);
          while (!Verilated::gotFinish()) { sc_start(1); }
      }
    EOF

Now we run Verilator on our little example.

    export VERILATOR_ROOT=/path/to/where/verilator/was/installed
    $VERILATOR_ROOT/bin/verilator --sp our.v

Then we convert the SystemPerl output to SystemC.

    cd obj_dir
    export SYSTEMPERL=/path/to/where/systemperl/kit/came/from
    $SYSTEMPERL/sp_preproc --preproc *.sp

(You can also skip the above sp_preproc by getting pure SystemC from
verilator by replacing the verilator --sp flag in the previous step with
-sc.)

We then can compile it

    make -f Vour.mk Vour__ALL.a
    make -f Vour.mk ../sc_main.o
    make -f Vour.mk verilated.o

And link with SystemC.  Note your path to the libraries may vary,
depending on the operating system.

    export SYSTEMC=/path/to/where/systemc/was/built/or/installed
    g++ -L$SYSTEMC/lib-linux ../sc_main.o Vour__ALL*.o verilated.o \
              -o Vour -lsystemc

And now we run it

    cd ..
    obj_dir/Vour

And we get the same output as the C++ example:

    Hello World
    - our.v:2: Verilog $finish

Really, you're better off using a Makefile to do all this for you.  Then,
when your source changes it will automatically run all of these steps.  See
the test_sp directory in the distribution for an example.

=head1 BENCHMARKING & OPTIMIZATION

For best performance, run Verilator with the "-O3 -x-assign=0 --noassert"
flags.  The -O3 flag will require longer compile times, and -x-assign=0 may
increase the risk of reset bugs in trade for performance; see the above
documentation for these flags.

Minor Verilog code changes can also give big wins.  You should not have any
UNOPTFLAT warnings from Verilator.  Fixing these warnings can result in
huge improvements; one user fixed their one UNOPTFLAT warning by making a
simple change to a clock latch used to gate clocks and gained a 60%
performance improvement.

Beyond that, the performance of a Verilated model depends mostly on your
C++ compiler and size of your CPU's caches.

By default, the lib/verilated.mk file has optimization turned off.  This is
for the benefit of new users, as it improves compile times at the cost of
runtimes.  To add optimization as the default, set one of three variables,
OPT, OPT_FAST, or OPT_SLOW in lib/verilated.mk. Or, just for one run, pass
them on the command line to make:

    make OPT_FAST="-O2" -f Vour.mk Vour__ALL.a

OPT_FAST specifies optimizations for those programs that are part of the
fast path, mostly code that is executed every cycle.  OPT_SLOW specifies
optimizations for slow-path files (plus tracing), which execute only
rarely, yet take a long time to compile with optimization on.  OPT
specifies overall optimization and affects all compiles, including those
OPT_FAST and OPT_SLOW affect.  For best results, use OPT="-O2".  Nearly the
same results can be had with much better compile times with OPT_FAST="-O1
-fstrict-aliasing".  Unfortunately, using the optimizer with SystemC files
can result in compiles taking several minutes.  (The SystemC libraries have
many little inlined functions that drive the compiler nuts.)

For best results, use GCC 3.3 or newer.  GCC 3.2 and earlier have
optimization bugs around pointer aliasing detection, which can result in 2x
performance losses.

If you will be running many simulations on a single compile, investigate
feedback driven compilation.  With GCC, using -fprofile-arcs, then
-fbranch-probabilities will yield another 15% or so.

You may uncover further tuning possibilities by profiling the Verilog code.
Use Verilator's --profile-cfuncs, then GCC's -g -pg.  You can then run
either oprofile or gprof to see where in the C++ code, and by looking at
the mangled function name where in the Verilog code most of the time is
being spent.

When done, please let the author know the results.  I like to keep tabs on
how Verilator compares, and may be able to suggest additional improvements.

=head1 FILES

Verilator creates the following files:

    {prefix}.mk				// Make include file for compiling
    {prefix}_classes.mk			// Make include file with class names

For -cc and -sc mode, it also creates:

    {prefix}.cpp			// Top level C++ file
    {prefix}.h				// Top level header
    {prefix}{each_verilog_module}.cpp	// Lower level internal C++ files
    {prefix}{each_verilog_module}.h	// Lower level internal header files

For -sp mode, it also creates:

    {prefix}.sp				// Top level SystemC file
    {prefix}{each_verilog_module}.sp	// Lower level internal SC files

In certain optimization modes, it also creates:

    {prefix}__Slow.cpp			// Constructors and infrequent routines
    {prefix}__Syms.cpp			// Global symbol table C++
    {prefix}__Syms.h			// Global symbol table header
    {prefix}__Trace.cpp			// Wave file generation code (--trace)
    {prefix}__stats.txt			// Statistics (--stats)

It also creates internal files that can be mostly ignored:

    {each_verilog_module}.vpp		// Post-processed verilog source code
    {prefix}.flags_vbin			// Verilator dependencies
    {prefix}.flags_vpp			// Pre-processor dependencies
    {prefix}{misc}.d			// Make dependencies (-MMD)
    {prefix}{misc}.dot			// Debugging graph files (--debug)
    {prefix}{misc}.tree			// Debugging files (--debug)

After running Make, the compiler will produce the following:
    {prefix}				// Final executable (w/--exe argument)
    {prefix}__ALL.a			// Library of all Verilated objects
    {prefix}{misc}.o			// Intermediate objects

=head1 ENVIRONMENT

=over 4

=item SYSTEMC

Required for SystemC output mode.  If set, specifies the directory
containing the SystemC distribution.  This is used to find the SystemC
include files.

=item SYSTEMC_ARCH

Specifies the architecture name used by the SystemC kit.  This is the part
after the dash in the lib-{...} directory name created by a 'make' in the
SystemC distribution.  If not set, Verilator will try to intuit the proper
setting.

=item SYSTEMC_CXX_FLAGS

Specifies additional flags that are required to be passed to GCC when
building the SystemC model.

=item SYSTEMPERL

Specifies the directory containing the Verilog-Perl distribution kit.  This
is used to find the Verilog-Perl library and include files.

=item VCS_HOME

If set, specifies the directory containing the Synopsys VCS distribution.
When set, a 'make test' in the Verilator distribution will also run VCS
baseline regression tests.

=item VERILATOR_BIN

If set, specifies an alternative name of the Verilator binary.  May be used
for debugging and selecting between multiple operating system builds.

=item VERILATOR_ROOT

Specifies the directory containing the distribution kit.  This is used to
find the executable, Perl library, and include files.

=back

=head1 CONNECTING TO C++

Verilator creates a .h and .cpp file for the top level module and all
modules under it.  See the test_c directory in the kit for an example.

After the modules are completed, there will be a I<module>.mk file that may
be used with Make to produce a I<module>__ALL.a file with all required
objects in it.  This is then linked with the user's top level to create the
simulation executable.

The user must write the top level of the simulation.  Here's a simple
example:

	#include <verilated.h>		// Defines common routines
	#include "Vtop.h"		// From Verilating "top.v"

	Vtop *top;			// Instantiation of module

	unsigned int main_time = 0;	// Current simulation time

	double sc_time_stamp () {	// Called by $time in Verilog
    	    return main_time;
	}

	int main() {
	    top = new Vtop;		// Create instance

	    top->reset_l = 0;		// Set some inputs

	    while (!Verilated::gotFinish()) {
		if (main_time > 10) {
		    top->reset_l = 1;	// Deassert reset
		}
		if ((main_time % 10) == 1) {
		    top->clk = 1;	// Toggle clock
		}
		if ((main_time % 10) == 6) {
		    top->clk = 0;
		}
		top->eval();		// Evaluate model
		cout << top->out << endl;	// Read a output
		main_time++;		// Time passes...
	    }

	    top->final();		// Done simulating
	    //	  // (Though this example doesn't get here)
	}

Note signals are read and written as member variables of the lower module.
You call the eval() method to evaluate the model.  When the simulation is
complete call the final() method to wrap up any SystemVerilog final blocks,
and complete any assertions.

=head1 CONNECTING TO SYSTEMC

Verilator will convert the top level module to a SC_MODULE.  This module
will plug directly into a SystemC netlist.

The SC_MODULE gets the same pinout as the Verilog module, with the
following type conversions: Pins of a single bit become bool, unless they
are marked with `systemc_clock, in which case they become sc_clock's (for
SystemC 1.2, not needed in SystemC 2.0).  Pins 2-32 bits wide become
uint32_t's.  Pins 33-64 bits wide become sc_bv's or uint64_t's depending on
the -pins64 switch.  Wider pins become sc_bv's.

Lower modules are not pure SystemC code.  This is a feature, as using the
SystemC pin interconnect scheme everywhere would reduce performance by an
order of magnitude.

=head1 VERILOG 2001 SUPPORT

Verilator supports the more common Verilog 2001 language features.  This
includes signed numbers, "always @*", comma separated sensitivity lists,
generate statements, multidimensional arrays, localparam, and C-style
declarations inside port lists.

=head1 SYSTEMVERILOG 3.1 SUPPORT

Verilator currently has very minimal support for SystemVerilog.

Verilator implement the full SystemVerilog 3.1 preprocessor subset,
including function call-like preprocessor defines.  Verilator also
implements $bits, $countones, $isunknown, $onehot, and $onehot0,
always_comb, always_ff, always_latch, and final.

=head1 SUGAR/PSL SUPPORT

With the --assert switch, Verilator is just beginning to support the
Property Specification Language (PSL), specifically the simple subset
without time-branching primitives.  Verilator currently only converts PSL
assertions to simple "if (...) error" statements, and coverage statements
to increment the line counters described in the coverage section.  If you
need additional features please contact the author.

Verilator implements these keywords: assert, assume (same as assert),
default (for clocking), countones, cover, isunknown, onehot, onehot0,
report, true.

Verilator implements these operators: -> (logical if).

Verilator does not support SEREs yet.  All assertion and coverage
statements must be simple expressions that complete in one cycle.
(Arguably SEREs are the whole point of PSL, but one must start somewhere.)

PSL vmode/vprop/vunits are not supported.  PSL statements must be in the
module they reference, at the module level where you would put an
initial... statement.

Verilator only supports (posedge CLK) or (negedge CLK), where CLK is the
name of a one bit signal.  You may not use arbitrary expressions as
assertion clocks.

=head1 SYNTHESIS DIRECTIVE ASSERTIONS

With the --assert switch, Verilator reads any "//synopsys full_case" or "//
synopsys parallel_case" directives.  The same applies to any "//cadence" or
"// ambit synthesis" directives of the same form.

When these synthesis directives are discovered, Verilator will either
formally prove the directive to be true, or failing that, will insert the
appropriate code to detect failing cases at runtime and print an "Assertion
failed" error message.

=head1 LANGUAGE EXTENSIONS

The following additional constructs are the extensions Verilator supports
on top of standard Verilog code.  Using these features outside of comments
or `ifdef's may break other tools.

=over 4

=item `__FILE__

The __FILE__ define expands to the current filename, like C++'s __FILE__.

=item `__LINE__

The __LINE__ define expands to the current line number, like C++'s __LINE__.

=item `error I<string>

This will report an error when encountered, like C++'s #error.

=item _(I<expr>)

A underline followed by an expression in parenthesis returns a Verilog
expression.  This is different from normal parenthesis in special contexts,
such as PSL expressions, and can be used to embed bit concatenation ({})
inside of PSL statements.

=item $c(I<string>, ...);

The string will be embedded directly in the output C++ code at the point
where the surrounding Verilog code is compiled.  It may either be a
standalone statement (with a trailing ; in the string), or a function that
returns up to a 32-bit number (without a trailing ;). This can be used to
call C++ functions from your Verilog code.

String arguments will be put directly into the output C++ code.  Expression
arguments will have the code to evaluate the expression inserted.  Thus to
call a C++ function, $c("func(",a,")") will result in 'func(a)' in the
output C++ code.  For input arguments, rather then hardcoding variable
names in the string $c("func(a)"), instead pass the variable as an
expression $c("func(",a,")").  This will allow the call to work inside
Verilog functions where the variable is flattened out, and also enable
other optimizations.

If you will be reading or writing any Verilog variables inside the C++
functions, the Verilog signals must be declared with /*verilator public*/.

You may also append a arbitrary number to $c, generally the width of the
output.  [signal_32_bits = $c32("...");] This allows for compatibility with
other simulators which require a differently named PLI function name for
each different output width.

=item $display, $write, $fdisplay, $fwrite

$display format arguments may use C fprintf sizes after the % escape.  Per
the Verilog standard, %x prints a number with the natural width, %0x prints
a number with minimum width, however %5x prints 5 digits per the C standard
(it's unspecified in Verilog).

=item $fopen, $fclose, $fdisplay, $fwrite

File descriptors passed to the file PLI calls must be file descriptors, not
MCDs, which includes the mode parameter to $fopen being mandatory.
Verilator will convert the integer used to hold the file descriptor into a
internal FILE*. To prevent core dumps due to mis-use, and because integers
are 32 bits while FILE*s may be 64 bits, the descriptor must be stored in a
reg [63:0] rather then an integer.  The define `verilator_file_descriptor in
verilated.v can be used to hide this difference.

=item `coverage_block_off

Specifies the entire begin/end block should be ignored for coverage analysis.
Same as /* verilator coverage_block_off */.

=item `systemc_header

Take remaining text up to the next `verilog or `systemc_... mode switch and
place it verbatim into the output .h file's header.  Despite the name of this
macro, this also works in pure C++ code.

=item `systemc_ctor

Take remaining text up to the next `verilog or `systemc_... mode switch and
place it verbatim into the C++ class constructor.  Despite the name of this
macro, this also works in pure C++ code.

=item `systemc_dtor

Take remaining text up to the next `verilog or `systemc_... mode switch and
place it verbatim into the C++ class destructor.  Despite the name of this
macro, this also works in pure C++ code.

=item `systemc_interface

Take remaining text up to the next `verilog or `systemc_... mode switch and
place it verbatim into the C++ class interface.  Despite the name of this
macro, this also works in pure C++ code.

=item `systemc_imp_header

Take remaining text up to the next `verilog or `systemc_... mode switch and
place it verbatim into the header of all files for this C++ class
implementation.  Despite the name of this macro, this also works in pure
C++ code.

=item `systemc_implementation

Take remaining text up to the next `verilog or `systemc_... mode switch and
place it verbatim into a single file of the C++ class implementation.
Despite the name of this macro, this also works in pure C++ code.

If you will be reading or writing any Verilog variables in the C++
functions, the Verilog signals must be declared with /*verilator public*/.
See also the public task feature; writing a accessor may result in cleaner
code.

=item `verilator

=item `verilator3

The verilator and verilator3 defines are set by default so you may `ifdef
around compiler specific constructs.

=item `verilog

Switch back to processing Verilog code, after a `systemc_... mode switch.

=item /*verilator clock_enable*/

Experimental use only.  Used after a signal declaration to indicate the
signal is used to gate a clock, and the user takes responsibility for
insuring there are no races related to it.  (Typically by adding a latch,
and running static timing analysis.) This will cause the clock gate to be
ignored in the scheduling algorithm, improving performance.

=item /*verilator coverage_block_off*/

Specifies the entire begin/end block should be ignored for coverage analysis.

=item /*verilator inline_module*/

Specifies the module the comment appears in may be inlined into any modules
that use this module.  This is useful to speed up simulation time with some
small loss of trace visibility and modularity.  Note signals under inlined
submodules will be named I<submodule>__DOT__I<subsignal> as C++ does not
allow "." in signal names.  SystemPerl when tracing such signals will
replace the __DOT__ with the period.

=item /*verilator lint_off I<msg>*/

Disable the specified warning message for any warnings following the comment.

=item /*verilator lint_on I<msg>*/

Re-enable the specified warning message for any warnings following the comment.

=item /*verilator sc_clock*/

Used after a input declaration to indicate the signal should be declared in
SystemC as a sc_clock instead of a bool.

=item /*verilator tracing_off*/

Disable waveform tracing for all future signals that are declared in this
module.  Often this is placed just after a primitive's module statement, so
that the entire module is not traced.

=item /*verilator tracing_on*/

Re-enable waveform tracing for all future signals that are declared.

=item /*verilator public*/ (variable)

Used after a input, output, register, or wire declaration to indicate the
signal should be declared so that C code may read or write the value
of the signal.  Set for all signals when using the --public switch.

=item /*verilator public*/ (task/function)

Used inside the declaration section of a function or task declaration to
indicate the function or task should be made into a C++ function, public to
outside callers.  Public tasks will be declared as a void C++ function,
public functions will get the appropriate non-void (bool, uint32_t, etc)
return type.  Any input arguments will become C++ arguments to the
function.  Any output arguments will become C++ reference arguments.  Any
local registers/integers will become function automatic variables on the
stack.

Wide variables over 64 bits cannot be I/O to the module, to avoid exposing
complexities; generally the cleanest technique is to pass a word number to
the function, and do appropriate bit selection.

This feature is still somewhat experimental.  Generally, only the values of
stored state (flops) should be written, as the model will NOT notice
changes made to variables in these functions.  (Same as when a signal is
declared public.)

=item /*verilator public_module*/

Used after a module statement to indicate the module should not be inlined
(unless specifically requested) so that C code may access the module.
Verilator automatically sets this attribute when the module contains any
public signals or `systemc_ directives.  Also set for all modules when
using the --public switch.

=back

=head1 LANGUAGE LIMITATIONS

There are some limitations and lack of features relative to a commercial
simulator, by intent.  User beware.

It is strongly recommended you use a lint tool before running this program.
Verilator isn't designed to easily uncover common mistakes that a lint
program will find for you.

=head2 Synthesis Subset

Verilator supports only the Synthesis subset with a few minor additions
such as $stop, $finish and $display.  That is, you cannot use hierarchical
references, events or similar features of the Verilog language.  It also
simulates as Synopsys's Design Compiler would; namely a block of the form

	always @ (x)   y = x & z;

will recompute y when there is a change in x or a change in z, which is
what Design Compiler will synthesize.  A compliant simulator would only
calculate y if x changes.  (Use verilog-mode's /*AS*/ or Verilog 2001's
always @* to prevent these issues.)

=head2 Dotted cross-hierarchy references

Verilator supports dotted references to variables, functions and tasks in
different modules. However, references into named blocks and function-local
variables are not supported.

=head2 Latches

Verilator is optimized for edge sensitive (flop based) designs.  It will
attempt to do the correct thing for latches, but most performance
optimizations will be disabled around the latch.

=head2 Time

All delays (#) are ignored, as they are in synthesis.

=head2 Two State

Verilator is a two state simulator, not a four state simulator.  However, it
has two features which uncover most initialization bugs (including many that
a four state simulator will miss.)

First, assigning a variable to a X will actually assign the variable to a
random value (see the -x-assign switch.)  Thus if the value is actually
used, the random value should cause downstream errors.  Integers also
randomize, even though the Verilog 2001 specification says they initialize
to zero.

Identity comparisons (=== or !==) are converted to standard ==/!== when
neither side is a constant.  This may make the expression result differ
from a four state simulator.

All variables are initialized using a function.  By running several
random simulation runs you can determine that reset is working correctly.
On the first run, the function initializes variables to zero.  On the
second, have it initialize variables to one.  On the third and following
runs have it initialize them randomly.  If the results match, reset works.
(Note this is what the hardware will really do.)  In practice, just setting
all variables to one at startup finds most problems.

=head2 Tri/Inout

As a 2 state compiler, tristate and inouts are not supported.
Traditionally only chip "cores" are Verilated, the pad rings have been
written by hand in C++.

=head2 Functions & Tasks

All functions and tasks will be inlined (will not become functions in C.)
The only support provided is for simple statements in tasks (which may
affect global variables).

Recursive functions and tasks are not supported.  All inputs and outputs
are automatic, as if they had the Verilog 2001 "automatic" keyword
prepended.  (If you don't know what this means, Verilator will do what you
probably expect -- what C does. The default behavior of Verilog is
different.)

=head2 Generate Statements

All instantiations and variables in generate blocks will be placed under
hierarchy that has a name different from that required in the language
specification.

=head2 Generated Clocks

Verilator attempts to deal with generated clocks correctly, however new
cases may turn up bugs in the scheduling algorithm.  The safest option is
to have all clocks as primary inputs to the model.

=head2 Ranges must be big-bit-endian

Bit ranges must be numbered with the MSB being numbered greater or the same
as the LSB.  Little-bit-endian busses [0:15] are not supported as they
aren't easily made compatible with C++.

=head2 32-Bit Divide

The division and modulus operators are limited to 32 bits.  This can be
easily fixed if someone contributes the appropriate wide-integer math
functions.

=head2 Gate Primitives

The 2-state gate primitives (and, buf, nand, nor, not, or, xnor, xor) are
directly converted to behavioral equivalents.  The 3-state and MOS gate
primitives are not supported.  Tables are not supported.

=head2 Specify blocks

All specify blocks and timing checks are ignored.

=head2 Array Initialization

When initializing an array, you need to use non-delayed assignments.  This
is done in the interest of speed; if delayed assignments were used, the
simulator would have to copy large arrays every cycle.  (In smaller loops,
loop unrolling allows the delayed assignment to work, though it's a bit
slower then a non-delayed assignment.)  Here's an example

	always @ (posedge clk)
            if (~reset_l) begin
                for (i=0; i<`ARRAY_SIZE; i++) begin
		    array[i] = 0;	 // Non-delayed for verilator
                end

=head2 Array Out of Bounds

Writing a memory element that is outside the bounds specified for the array
may cause a different memory element inside the array to be written
instead.  For power-of-2 sized arrays, Verilator will give a width warning
and the address.  For non-power-of-2-sizes arrays, index 0 will be written.

Reading a memory element that is outside the bounds specified for the array
will give a width warning and wrap around the power-of-2 size.  For
non-power-of-2 sizes, it will return a unspecified constant of the
appropriate width.

=head1 ERRORS

Warnings may be disabled in two ways.  First, when the warning is
printed it will include a warning code.  Simply surround the offending
line with a warn_off/warn_on pair:

	// verilator lint_off UNSIGNED
	if (`DEF_THAT_IS_EQ_ZERO <= 3) $stop;
	// verilator lint_on UNSIGNED

They may also be globally disabled by invoking Verilator with the
C<-Wno-I<warning>> switch.  This should be avoided, as it removes
all checking across the designs, and prevents other users from
compiling your code without knowing the magic set of disables needed
to successfully compile your design.

Warnings:

=over 4

=item CASEINCOMPLETE

Warns that inside a case statement there is a stimulus pattern for which
there is no case item specified.  This is bad style, if a case is
impossible, it's better to have a "default: $stop;" or just "default: ;" so
that any design assumption violations will be discovered in simulation.

=item CASEOVERLAP

Warns that inside a case statement you have case values which are detected
to be overlapping.  This is bad style, as moving the order of case values
will cause different behavior.  Generally the values can be respecified to
not overlap.

=item CASEX

Warns that it is simply better style to use casez, and C<?> in place of
C<x>'s.  See
L<http://www.sunburst-design.com/papers/CummingsSNUG1999Boston_FullParallelCase_rev1_1.pdf>

=item CMPCONST

Warns that you are comparing a value in a way that will always be constant.
For example "X > 1" will always be true when X is a single bit wide.

=item COMBDLY

Warns that you have a delayed assignment inside of a combinatorial block.
Using delayed assignments in this way is considered bad form, and may lead
to the simulator not matching synthesis.  If this message is suppressed,
Verilator, like synthesis, will convert this to a non-delayed assignment,
which may result in logic races or other nasties.  See
L<http://www.sunburst-design.com/papers/CummingsSNUG2000SJ_NBA_rev1_2.pdf>

=item GENCLK

Warns that the specified signal is generated, but is also being used as a
clock.  Verilator needs to evaluate sequential logic multiple times in this
situation. In somewhat contrived cases having any generated clock can
reduce performance by almost a factor of two.  For fastest results,
generate ALL clocks outside in C++/SystemC and make them primary inputs to
your Verilog model.  (However once need to you have even one, don't sweat
additional ones.)

=item IMPLICIT

Warns that a wire is being implicitly declared (it is a single bit wide
output from a sub-module.)  While legal in Verilog, implicit declarations
only work for single bit wide signals (not buses), do not allow using a
signal before it is implicitly declared by a cell, and can lead to dangling
nets.  A better option is the /*AUTOWIRE*/ feature of Verilog-Mode for
Emacs, available from L<http://www.veripool.com/>

=item MULTIDRIVEN

Warns that the specified signal comes from multiple always blocks.  This is
often unsupported by synthesis tools, and is considered bad style.  It will
also cause longer runtimes due to reduced optimizations.

=item UNDRIVEN

Warns that the specified signal is never sourced.

=item UNOPT

Warns that due to some construct, optimization of the specified signal or
block is disabled.  The construct should be cleaned up to improve runtime.

A less obvious case of this is when a module instantiates two submodules.
Inside submodule A, signal I is input and signal O is output.  Likewise in
submodule B, signal O is an input and I is an output.  A loop exists and a
UNOPT warning will result if AI & AO both come from and go to combinatorial
blocks in both submodules, even if they are unrelated always blocks.  This
affects performance because Verilator would have to evaluate each submodule
multiple times to stabilize the signals crossing between the modules.

=item UNOPTFLAT

Warns that due to some construct, optimization of the specified signal is
disabled.  The signal specified includes a complete scope to the signal; it
may be only one particular usage of a multiply instantiated block.  The
construct should be cleaned up to improve runtime; two times better
performance may be possible by fixing these warnings.

Unlike UNOPT this occurs after netlist flattening, and indicates a more
basic problem, as the less obvious case described under UNOPT does not
apply.

Often this is caused by logic that isn't truly circular as viewed by
synthesis which analyzes interconnection per-bit, but is circular to
simulation which analyzes per-bus:

      wire [2:0] x = {x[1:0],shift_in};

This statement needs to be evaluated multiple times, as a change in
"shift_in" requires "x" to be computed 3 times before it becomes stable.
For significantly better performance, split this into 2 separate signals:

      wire [2:1] x_21 = x[1:0];
      wire [0:0] x_0  = shift_in;

=item UNSIGNED

Warns that you are comparing a unsigned value in a way that implies it is
signed, for example "X < 0" will always be true when X is unsigned.

=item UNUSED

Warns that the specified signal is never sinked.  This is a future message,
currently Verilator will not produce this warning.

=item VARHIDDEN

Warns that a task, function, or begin/end block is declaring a variable by
the same name as a variable in the upper level module or begin/end block
(thus hiding the upper variable from being able to be used.)  Rename the
variable to avoid confusion when reading the code.

=item WIDTH

Warns that based on width rules of Verilog, two operands have different
widths.  Verilator generally can intuit the common usages of widths, and
you shouldn't need to disable this message like you do with most lint
programs.  Generally other then simple mistakes, you have two solutions:

If it's a constant 0 that's 32 bits or less, simply leave it
unwidthed. Verilator considers zero to be any width needed.

Concatenate leading zeros when doing arithmetic.  In the statement

	wire [5:0] plus_one = from[5:0] + 6'd1 + carry[0];

The best fix, which clarifies intent and will also make all tools happy is:

	wire [5:0] plus_one = from[5:0] + 6'd1 + {5'd0,carry[0]};

=back

The following describes the less obvious errors:

=over 4

=item Internal Error

This error should never occur first, though may occur if earlier warnings
or error messages have corrupted the program.  If there are no other
warnings or errors, submit a bug report.

=item Unsupported: ....

This error indicates that you are using a Verilog language construct
that is not yet supported in Verilator.  See the Limitations chapter.

=item Verilated model didn't converge

Verilator sometimes has to evaluate combinatorial logic multiple times,
usually around code where a UNOPT warning was issued, but disabled.  For
example:

   always @ (a)  b=~a;
   always @ (b)  a=b

will toggle forever and thus the executable will give the didn't converge
error to prevent an infinite loop.  To debug this, compile the Verilated
.cpp files with -DVL_DEBUG, then call Verilated::debug(1) in your main.cpp.
This will cause each module to print a message when it's invoked.  From
that it should be obvious what routine(s) are part of the infinite loop.
Then in Gdb, add a break point at the routine entry point and "print *this"
on each loop so you can see what variables are changing each invocation.

=back

=head1 FAQ/FREQUENTLY ASKED QUESTIONS

=over 4

=item Does it run under Windows?

Yes, using Cygwin.  Verilated output should also compile under Microsoft
Visual C++ Version 7 or newer, but this is not tested by the author.

=item Can you provide binaries?

At this time I'd prefer to get patches out quickly then have to generate
myriad binaries for many different OS flavors.  People have generally
requested binaries when they are having problems with their C++
compiler. Alas, binaries won't help this, as in the end a fully working C++
compiler is required to compile the output of Verilator.

=item How can it be faster then (name-the-simulator)?

Generally, the implied part of the question is "... with all of their
manpower they can put into it."

Most commercial simulators have to be Verilog compliant, meaning event
driven.  This prevents them from being able to reorder blocks and make
netlist-style optimizations, which are where most of the gains come from.

Non-compliance shouldn't be scary.  Your synthesis program isn't compliant,
so your simulator shouldn't have to be -- and Verilator is closer to the
synthesis interpretation, so this is a good thing for getting working
silicon.

=item How do I generate waveforms (traces)?

Add the --trace switch to Verilator, and make sure the SystemPerl package
is installed (SystemC itself isn't required for C++ only tracing.)  In your
top level C code, call Verilated::traceEverOn(true).

Then, in SystemC mode, create a SpTraceFile object.  For an example, see
the call to SpTraceFile in the test_sp/sc_main.cpp file of the
distribution.

Or, in C++ mode, create a SpTraceVcdCFile object, and see
test_c/sim_main.cpp.

=item Where is the translate_off command?  (How do I ignore a construct?)

Translate on/off pragmas are generally a bad idea, as it's easy to have
mismatched pairs, and you can't see what another tool sees by just
preprocessing the code.  Instead, use the preprocessor; Verilator defines
the "verilator" define for you, so just wrap the code in a ifndef region:

   `ifndef verilator
      Something_Verilator_Dislikes;
   `endif

=item How do I prevent my assertions from firing during reset?

Call Verilated::assertOn(false) before you first call the model, then turn
it back on after reset.  It defaults to true.  When false, all assertions
controlled by --assert are disabled.

=item Is the PLI supported?

No.

More specifically, the common PLI-ish calls $display, $finish, $stop,
$time, $write are converted to C++ equivalents.  If you want something more
complex, since Verilator emits standard C++ code, you can simply write your
own C++ routines that can access and modify signal values without needing
any PLI interface code, and call it with $c("{any_c++_statement}").

=item How do I get faster build times?

Between GCC 3.0 to 3.3, each compiled progressively slower, thus if you can
use GCC 2.95, or GCC 3.4 you'll have faster builds.  Two ways to cheat are
to compile on parallel machines and avoid compilations altogether.  See the
--output-split option, and the web for the ccache, distcc and icecream
packages, and the Make::Cache package available from
L<http://www.veripool.com/>. Make::Cache will skip GCC runs between
identical source builds, even across different users.

=item Why do so many files need to recompile when I add a signal?

Adding a new signal requires the symbol table to be recompiled.  Verilator
uses one large symbol table, as that results in 2-3 less assembly
instructions for each signal access.  This makes the execution time 10-15%
faster, but can result in more compilations when something changes.

=item How do I access signals in C?

First, declare the signals you will be accessing with a /*verilator
public*/ comment before the closing semicolon.  Then scope into the C++
class to read the value of the signal, as you would any other member variable.

Signals are the smallest of 8 bit chars, 16 bit shorts, 32 bit longs, or 64
bit long longs that fits the width of the signal.  Generally, you can use
just uint32_t's for 1 to 32 bits, or uint64_t for 1 to 64 bits, and the
compiler will properly up-convert smaller entities.

Signals wider then 64 bits are stored as an array of 32-bit uint32_t's.
Thus to read bits 31:0, access signal[0], and for bits 63:32, access
signal[1].  Unused bits (for example bit numbers 65-96 of a 65 bit vector)
will always be zero.  if you change the value you must make sure to pack
zeros in the unused bits or core-dumps may result.  (Because Verilator
strips array bound checks where it believes them to be unnecessary.)

In the SYSTEMC example above, if you had in our.v:

         input clk /*verilator public*/;

From the sc_main.cpp file, you'd then:

    #include "Vour.h"
    #include "Vour_our.h"
    cout << "clock is " << top->v.clk << endl;

In this example, clk is a bool you can read or set as any other variable.
The value of normal signals may be set, though clocks shouldn't be changed
by your code or you'll get strange results.

=back

=head1 BUGS

First, check the the coding limitations section.

Next, try the --debug switch.  This will enable additional internal
assertions, and may help identify the problem.

Finally, reduce your code to the smallest possible routine that exhibits
the bug.  Even better, create a test in the test_regress/t directory, as
follows:

    cd test_regress
    cp -p t/t_EXAMPLE.pl t/t_BUG.pl
    cp -p t/t_EXAMPLE.v t/t_BUG.v

Edit t/t_BUG.pl to suit your example; you can do anything you want in the
Verilog code there; just make sure it retains the single clk input and no
outputs.  Now, the following should fail:

    cd test_regress
    t/t_BUG.pl

Finally, Mail the bug report to C<wsnyder@wsnyder.org>

=head1 HISTORY

Verilator was conceived in 1994 by Paul Wasson at the Core Logic Group
at Digital Equipment Corporation.  The Verilog code that was converted
to C was then merged with a C based CPU model of the Alpha processor
and simulated in a C based environment called CCLI.

In 1995 Verilator started being used also for Multimedia and Network
Processor development inside Digital.  Duane Galbi took over active
development of Verilator, and added several performance enhancements.
CCLI was still being used as the shell.

In 1998, through the efforts of existing DECies, mainly Duane Galbi,
Digital graciously agreed to release the source code.  (Subject to the
code not being resold, which is compatible with the GNU Public
License.)

In 2001, Wilson Snyder took the kit, and added a SystemC mode, and
called it Verilator2.  This was the first packaged public release.

In 2002, Wilson Snyder created Verilator3 by rewriting Verilator from
scratch in C++.  This added many optimizations, yielding about a 2-5x
performance gain.

Currently, various language features and performance enhancements are added
as the need arises.  Verilator is now about 2x faster then in 2002, and
as fast as most popular commercial simulators.

=head1 CONTRIBUTORS

Many people have provided ideas and other assistance with Verilator.

The major corporate sponsors of Verilator, by providing funds or equipment
grants, are Compaq Corporation, Digital Equipment Corporation, Maker
Communications, Sun Microsystems, Nauticus Networks, and SiCortex.

The people who have contributed code or other major functionality are Paul
Wasson, Duane Galbi, and Wilson Snyder.  Major testers include Jeff Dutton,
Ralf Karge and Wim Michiels.

Some of the people who have provided ideas and feedback for Verilator
include Hans Van Antwerpen, Jens Arm, David Black, Gregg Bouchard, Chris
Boumenot, John Brownlee, Lauren Carlson, Robert A. Clark, John Deroo, Danny
Ding, Jeff Dutton, Eugen Fekete, Sam Gladstone, Thomas Hawkins, Mike Kagen,
Ralf Karge, Dan Katz, Sol Katzman, Gernot Koch, Steve Kolecki, Steve Lang,
Charlie Lind, Dan Lussier, Fred Ma, Wim Michiels, John Murphy, Richard
Myers, Paul Nitza, Lisa Noack, Renga Sundararajan, Shawn Wang, Greg Waters,
Eugene Weber, Leon Wildman, and Mat Zeno.

=head1 DISTRIBUTION

The latest version is available from L<http://www.veripool.com/>.

Copyright 2003-2006 by Wilson Snyder.  Verilator is free software; you can
redistribute it and/or modify it under the terms of either the GNU Lesser
General Public License or the Perl Artistic License.

=head1 AUTHORS

Wilson Snyder <wsnyder@wsnyder.org>

Major concepts by Paul Wasson and Duane Galbi.

=head1 SEE ALSO

L<systemperl>, L<vcoverage>, L<make>

=cut

######################################################################
